<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Twin2Clouds Documentation — Dataclass Pattern</title>
    <link rel="icon" type="image/x-icon" href="references/favicon.ico">
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

    <link rel="stylesheet" href="css/docs_styles.css" />

</head>

<body>

    <div class="layout">

        <aside id="nav-placeholder"></aside>

        <main class="p-4">

            <nav aria-label="breadcrumb" class="mb-3">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="docs-patterns.html">Design Patterns</a></li>
                    <li class="breadcrumb-item active" aria-current="page">Dataclass Pattern</li>
                </ol>
            </nav>

            <h1 class="mb-3">
                <i class="fa-solid fa-database me-2 text-secondary"></i>Dataclass Pattern
            </h1>

            <p class="text-muted mb-4">
                The Dataclass pattern uses Python's <code>@dataclass</code> decorator to create structured,
                immutable result containers. This replaces the Builder pattern from earlier versions with a simpler,
                more Pythonic approach to constructing result objects.
            </p>

            <!-- Pattern Overview -->
            <div class="card mb-4">
                <div class="card-header bg-secondary text-white">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-info-circle me-2"></i>What It Does</h2>
                </div>
                <div class="card-body">
                    <p>
                        Dataclasses provide automatic generation of special methods like <code>__init__</code>,
                        <code>__repr__</code>, and <code>__eq__</code> based on class attributes. They offer:
                    </p>

                    <div class="row">
                        <div class="col-md-6">
                            <h5>Benefits</h5>
                            <ul>
                                <li><strong>Reduced boilerplate</strong> — No manual __init__ required</li>
                                <li><strong>Type hints</strong> — Built-in type annotation support</li>
                                <li><strong>Immutability</strong> — Optional frozen mode prevents modification</li>
                                <li><strong>Default values</strong> — Easy specification of optional fields</li>
                                <li><strong>Post-init processing</strong> — __post_init__ for derived fields</li>
                            </ul>
                        </div>
                        <div class="col-md-6">
                            <h5>Dataclass vs Builder</h5>
                            <table class="table table-sm table-bordered">
                                <thead class="table-light">
                                    <tr>
                                        <th>Feature</th>
                                        <th>Dataclass</th>
                                        <th>Builder</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Boilerplate</td>
                                        <td class="text-success">Minimal</td>
                                        <td class="text-danger">High</td>
                                    </tr>
                                    <tr>
                                        <td>Method chaining</td>
                                        <td class="text-warning">Limited</td>
                                        <td class="text-success">Yes</td>
                                    </tr>
                                    <tr>
                                        <td>Type safety</td>
                                        <td class="text-success">Built-in</td>
                                        <td class="text-warning">Manual</td>
                                    </tr>
                                    <tr>
                                        <td>Pythonic</td>
                                        <td class="text-success">Yes</td>
                                        <td class="text-warning">Java-style</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="alert alert-info mt-3">
                        <i class="fa-solid fa-lightbulb me-1"></i>
                        <strong>Migration Note:</strong> The v2 architecture replaced
                        <code>LayerResultBuilder</code>
                        with the <code>LayerResult</code> dataclass, providing the same functionality with less code.
                    </div>
                </div>
            </div>

            <!-- Where It's Used -->
            <div class="card mb-4">
                <div class="card-header bg-dark text-white">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-folder-open me-2"></i>Where It's Used</h2>
                </div>
                <div class="card-body">
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>File</th>
                                <th>Dataclass</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>calculation_v2/layers/aws_layers.py</code></td>
                                <td><code>LayerResult</code></td>
                                <td>Structured output from layer cost calculations</td>
                            </tr>
                            <tr>
                                <td><code>api/calculation.py</code></td>
                                <td><code>CalcParams</code></td>
                                <td>Input parameter validation (via Pydantic BaseModel)</td>
                            </tr>
                            <tr>
                                <td><code>backend/fetch_data/</code></td>
                                <td><code>PricingTier</code></td>
                                <td>Tiered pricing structure representation</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Code Examples -->
            <div class="card mb-4">
                <div class="card-header bg-primary text-white">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-code me-2"></i>Code Examples</h2>
                </div>
                <div class="card-body">

                    <h5>LayerResult Dataclass</h5>
                    <p class="text-muted">The primary result container for layer cost calculations.</p>
                    <pre class="bg-dark text-light p-3 rounded"><code>from dataclasses import dataclass, field
from typing import Dict, Optional

@dataclass
class LayerResult:
    """
    Structured result from a layer cost calculation.
    
    Attributes:
        provider: Cloud provider identifier ('aws', 'azure', 'gcp')
        layer: Layer identifier ('L1_ingestion', 'L2_compute', etc.)
        total_cost: Total monthly cost for this layer
        data_size_gb: Data volume processed (optional)
        messages: Message count (optional)
        components: Breakdown of costs by component service
    """
    provider: str
    layer: str
    total_cost: float
    data_size_gb: float = 0.0
    messages: int = 0
    components: Dict[str, float] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate and normalize after initialization."""
        # Ensure provider is lowercase
        self.provider = self.provider.lower()
        
        # Ensure total_cost is non-negative
        if self.total_cost < 0:
            raise ValueError(f"total_cost cannot be negative: {self.total_cost}")
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON serialization."""
        return {
            "provider": self.provider,
            "layer": self.layer,
            "totalCost": self.total_cost,
            "dataSizeGB": self.data_size_gb,
            "messages": self.messages,
            "components": self.components
        }</code></pre>

                    <h5 class="mt-4">Creating LayerResult Instances</h5>
                    <p class="text-muted">Simple, readable construction without method chaining.</p>
                    <pre class="bg-dark text-light p-3 rounded"><code># Direct construction with named parameters
result = LayerResult(
    provider="aws",
    layer="L1_ingestion",
    total_cost=12.50,
    data_size_gb=0.5,
    messages=1000000,
    components={
        "iotCore": 8.25,
        "dispatcherLambda": 4.25
    }
)

# Access attributes directly
print(f"Layer: {result.layer}")
print(f"Cost: ${result.total_cost:.2f}")

# Iterate over components
for service, cost in result.components.items():
    print(f"  {service}: ${cost:.2f}")</code></pre>

                    <h5 class="mt-4">Comparison with Deprecated Builder Pattern</h5>
                    <p class="text-muted">The dataclass approach is more concise and Pythonic.</p>

                    <div class="row">
                        <div class="col-md-6">
                            <h6 class="text-danger">Old Builder Pattern (Deprecated)</h6>
                            <pre class="bg-dark text-light p-3 rounded" style="font-size: 0.85rem;"><code># Deprecated - do not use
result = (LayerResultBuilder("aws")
    .set_layer("L1_ingestion")
    .set_cost(12.50)
    .set_data_size(0.5)
    .set_messages(1000000)
    .add_component("iotCore", 8.25)
    .add_component("dispatcherLambda", 4.25)
    .include_components()
    .build())</code></pre>
                        </div>
                        <div class="col-md-6">
                            <h6 class="text-success">New Dataclass Pattern</h6>
                            <pre class="bg-dark text-light p-3 rounded" style="font-size: 0.85rem;"><code># Current approach
result = LayerResult(
    provider="aws",
    layer="L1_ingestion",
    total_cost=12.50,
    data_size_gb=0.5,
    messages=1000000,
    components={
        "iotCore": 8.25,
        "dispatcherLambda": 4.25
    }
)</code></pre>
                        </div>
                    </div>

                    <h5 class="mt-4">PricingTier Dataclass</h5>
                    <p class="text-muted">Used for representing tiered pricing structures.</p>
                    <pre class="bg-dark text-light p-3 rounded"><code>from dataclasses import dataclass
from typing import Union

@dataclass(frozen=True)  # Immutable
class PricingTier:
    """
    Represents a single tier in tiered pricing.
    
    Attributes:
        limit: Upper bound of this tier (use float('inf') for unlimited)
        price: Price per unit in this tier
    """
    limit: Union[float, int]
    price: float
    
    def __post_init__(self):
        """Validate tier data."""
        if self.price < 0:
            raise ValueError(f"Price cannot be negative: {self.price}")
    
    @classmethod
    def from_dict(cls, data: dict) -> 'PricingTier':
        """Create from dictionary (e.g., from JSON)."""
        limit = data.get('limit', float('inf'))
        # Handle "Infinity" string from JSON
        if isinstance(limit, str) and limit.lower() == 'infinity':
            limit = float('inf')
        return cls(limit=limit, price=data['price'])


# Example usage
tiers = [
    PricingTier(limit=1000000, price=0.0),      # First 1M free
    PricingTier(limit=10000000, price=0.40),    # Next 9M at $0.40/M
    PricingTier(limit=float('inf'), price=0.20) # Beyond at $0.20/M
]

# Calculate cost across tiers
def calculate_tiered_cost(usage: float, tiers: list[PricingTier]) -> float:
    total_cost = 0.0
    remaining = usage
    previous_limit = 0
    
    for tier in tiers:
        tier_size = tier.limit - previous_limit
        tier_usage = min(remaining, tier_size)
        total_cost += tier_usage * tier.price
        remaining -= tier_usage
        previous_limit = tier.limit
        
        if remaining <= 0:
            break
    
    return total_cost</code></pre>
                </div>
            </div>

            <!-- Best Practices -->
            <div class="card mb-4">
                <div class="card-header bg-success text-white">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-check-circle me-2"></i>Best Practices</h2>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6">
                            <h5>Do</h5>
                            <ul class="list-group">
                                <li class="list-group-item list-group-item-success">
                                    <i class="fa-solid fa-check me-2"></i>Use type hints for all fields
                                </li>
                                <li class="list-group-item list-group-item-success">
                                    <i class="fa-solid fa-check me-2"></i>Provide default values for optional fields
                                </li>
                                <li class="list-group-item list-group-item-success">
                                    <i class="fa-solid fa-check me-2"></i>Use <code>field(default_factory=...)</code>
                                    for mutable defaults
                                </li>
                                <li class="list-group-item list-group-item-success">
                                    <i class="fa-solid fa-check me-2"></i>Use <code>frozen=True</code> for immutable
                                    data
                                </li>
                                <li class="list-group-item list-group-item-success">
                                    <i class="fa-solid fa-check me-2"></i>Add validation in
                                    <code>__post_init__</code>
                                </li>
                            </ul>
                        </div>
                        <div class="col-md-6">
                            <h5>Don't</h5>
                            <ul class="list-group">
                                <li class="list-group-item list-group-item-danger">
                                    <i class="fa-solid fa-times me-2"></i>Use mutable default arguments directly
                                </li>
                                <li class="list-group-item list-group-item-danger">
                                    <i class="fa-solid fa-times me-2"></i>Add complex business logic to dataclasses
                                </li>
                                <li class="list-group-item list-group-item-danger">
                                    <i class="fa-solid fa-times me-2"></i>Create deeply nested dataclass hierarchies
                                </li>
                                <li class="list-group-item list-group-item-danger">
                                    <i class="fa-solid fa-times me-2"></i>Mix dataclass and regular class patterns
                                </li>
                            </ul>
                        </div>
                    </div>

                    <h5 class="mt-4">Mutable Default Gotcha</h5>
                    <pre class="bg-dark text-light p-3 rounded"><code># ❌ WRONG - mutable default shared across instances
@dataclass
class BadExample:
    items: list = []  # DON'T DO THIS!

# ✅ CORRECT - use default_factory
@dataclass
class GoodExample:
    items: list = field(default_factory=list)</code></pre>
                </div>
            </div>

            <!-- Extension Guide -->
            <div class="card mb-4">
                <div class="card-header bg-warning">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-plus-circle me-2"></i>How to Extend</h2>
                </div>
                <div class="card-body">
                    <h5>Adding a New Result Dataclass</h5>
                    <pre class="bg-dark text-light p-3 rounded"><code>from dataclasses import dataclass, field
from typing import Dict, List, Optional

@dataclass
class OptimizationResult:
    """
    Result of the full cost optimization across all providers.
    
    Attributes:
        cheapest_path: List of layer-provider pairs for optimal cost
        total_cost: Sum of all layer costs on cheapest path
        provider_costs: Full cost breakdown by provider
        selected_currency: Currency used for all costs
        timestamp: When calculation was performed
    """
    cheapest_path: List[str]
    total_cost: float
    provider_costs: Dict[str, Dict[str, float]]
    selected_currency: str = "USD"
    timestamp: Optional[str] = None
    
    def __post_init__(self):
        """Set timestamp if not provided."""
        if self.timestamp is None:
            from datetime import datetime
            self.timestamp = datetime.utcnow().isoformat()
    
    def get_savings_vs_single_provider(self, provider: str) -> float:
        """Calculate savings compared to using a single provider."""
        single_provider_cost = sum(
            self.provider_costs.get(provider, {}).values()
        )
        return single_provider_cost - self.total_cost</code></pre>

                    <div class="alert alert-info mt-3">
                        <i class="fa-solid fa-lightbulb me-1"></i>
                        <strong>Tip:</strong> For API input validation, consider using Pydantic's
                        <code>BaseModel</code>
                        instead of dataclass. Pydantic provides more powerful validation and automatic JSON
                        serialization.
                    </div>
                </div>
            </div>

            <!-- Navigation -->
            <div class="d-flex justify-content-between mt-4">
                <a href="docs-pattern-facade.html" class="btn btn-outline-secondary">
                    <i class="fa-solid fa-arrow-left me-2"></i>Facade Pattern
                </a>
                <a href="docs-pattern-factory.html" class="btn btn-primary">
                    Next: Factory Pattern<i class="fa-solid fa-arrow-right ms-2"></i>
                </a>
            </div>

        </main>

    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <button id="backToTop" class="btn btn-primary rounded-circle position-fixed bottom-0 end-0 m-4 shadow fade p-3"
        style="display:none;">
        <i class="fa-solid fa-arrow-up"></i>
    </button>

    <script src="js/docs-nav.js" defer></script>
</body>

</html>