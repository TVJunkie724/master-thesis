<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Twin2Clouds Documentation — Pure Functions Pattern</title>
    <link rel="icon" type="image/x-icon" href="references/favicon.ico">
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

    <link rel="stylesheet" href="css/docs_styles.css" />

</head>

<body>

    <div class="layout">

        <aside id="nav-placeholder"></aside>

        <main class="p-4">

            <nav aria-label="breadcrumb" class="mb-3">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="docs-patterns.html">Design Patterns</a></li>
                    <li class="breadcrumb-item active" aria-current="page">Pure Functions</li>
                </ol>
            </nav>

            <h1 class="mb-3">
                <i class="fa-solid fa-function me-2 text-success"></i>Pure Functions Pattern
            </h1>

            <p class="text-muted mb-4">
                Pure functions are the mathematical foundation of the Twin2Clouds cost calculation system.
                They compute pricing using deterministic formulas with no side effects, making them easy to test,
                verify, and extend.
            </p>

            <!-- Pattern Overview -->
            <div class="card mb-4">
                <div class="card-header bg-success text-white">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-info-circle me-2"></i>What It Does</h2>
                </div>
                <div class="card-body">
                    <p>
                        Pure functions take input values and pricing data, perform mathematical calculations, and return
                        a cost result. They have several key properties:
                    </p>
                    <ul>
                        <li><strong>Deterministic</strong> — Same inputs always produce the same output</li>
                        <li><strong>No side effects</strong> — Functions don't modify external state</li>
                        <li><strong>Referentially transparent</strong> — Can be replaced with their return value</li>
                        <li><strong>Easy to test</strong> — No mocking required, just assert input/output pairs</li>
                    </ul>

                    <div class="alert alert-info">
                        <i class="fa-solid fa-lightbulb me-1"></i>
                        <strong>Key Insight:</strong> All cost formulas follow the pattern:
                        <code>cost = f(usage_params, pricing_data)</code> where <code>f</code> is a pure function.
                    </div>
                </div>
            </div>

            <!-- Where It's Used -->
            <div class="card mb-4">
                <div class="card-header bg-dark text-white">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-folder-open me-2"></i>Where It's Used</h2>
                </div>
                <div class="card-body">
                    <table class="table table-bordered">
                        <thead class="table-light">
                            <tr>
                                <th>File</th>
                                <th>Function</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td rowspan="6"><code>calculation_v2/formulas/core_formulas.py</code></td>
                                <td><code>calculate_messaging_cost()</code></td>
                                <td><strong>CM</strong> — Message broker costs (IoT Core, IoT Hub, Pub/Sub)</td>
                            </tr>
                            <tr>
                                <td><code>calculate_execution_cost()</code></td>
                                <td><strong>CE</strong> — Serverless compute costs (Lambda, Functions, Cloud Functions)
                                </td>
                            </tr>
                            <tr>
                                <td><code>calculate_api_cost()</code></td>
                                <td><strong>CA</strong> — API Gateway request costs</td>
                            </tr>
                            <tr>
                                <td><code>calculate_storage_cost()</code></td>
                                <td><strong>CS</strong> — Database storage costs (DynamoDB, Cosmos DB, Firestore)</td>
                            </tr>
                            <tr>
                                <td><code>calculate_unit_cost()</code></td>
                                <td><strong>CU</strong> — Fixed per-unit costs (Digital Twins, Grafana)</td>
                            </tr>
                            <tr>
                                <td><code>calculate_transfer_cost()</code></td>
                                <td><strong>CT</strong> — Cross-cloud data transfer costs</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Formula Examples -->
            <div class="card mb-4">
                <div class="card-header bg-primary text-white">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-code me-2"></i>Code Examples</h2>
                </div>
                <div class="card-body">

                    <h5>Messaging Cost Formula (CM)</h5>
                    <p class="text-muted">Calculates the cost of message ingestion through cloud messaging services.</p>
                    <pre class="bg-dark text-light p-3 rounded"><code>def calculate_messaging_cost(
    messages_per_month: int,
    message_size_kb: float,
    price_per_message: float,
    price_per_kb: float = 0.0,
    free_tier_messages: int = 0,
    free_tier_kb: int = 0
) -> float:
    """
    Calculate messaging costs (CM formula).
    
    Args:
        messages_per_month: Total messages sent per month
        message_size_kb: Average message size in KB
        price_per_message: Cost per message
        price_per_kb: Cost per KB of data (optional)
        free_tier_messages: Number of free messages
        free_tier_kb: Free KB of data transfer
    
    Returns:
        Monthly messaging cost in selected currency
    """
    billable_messages = max(0, messages_per_month - free_tier_messages)
    message_cost = billable_messages * price_per_message
    
    total_kb = messages_per_month * message_size_kb
    billable_kb = max(0, total_kb - free_tier_kb)
    data_cost = billable_kb * price_per_kb
    
    return message_cost + data_cost</code></pre>

                    <h5 class="mt-4">Execution Cost Formula (CE)</h5>
                    <p class="text-muted">Calculates serverless function execution costs using tiered pricing.</p>
                    <pre class="bg-dark text-light p-3 rounded"><code>def calculate_execution_cost(
    executions: int,
    duration_ms: float,
    memory_mb: int,
    price_per_request: float,
    price_per_gb_second: float,
    free_tier_requests: int = 0,
    free_tier_gb_seconds: float = 0.0
) -> float:
    """
    Calculate serverless execution costs (CE formula).
    
    Uses the standard GB-seconds pricing model:
    cost = (requests * price_per_request) + (gb_seconds * price_per_gb_second)
    
    Args:
        executions: Number of function invocations
        duration_ms: Average execution duration in milliseconds
        memory_mb: Memory allocated to function
        price_per_request: Cost per invocation
        price_per_gb_second: Cost per GB-second
        free_tier_requests: Free monthly requests
        free_tier_gb_seconds: Free monthly GB-seconds
    
    Returns:
        Monthly execution cost
    """
    # Calculate billable requests
    billable_requests = max(0, executions - free_tier_requests)
    request_cost = billable_requests * price_per_request
    
    # Calculate GB-seconds
    duration_seconds = duration_ms / 1000
    memory_gb = memory_mb / 1024
    total_gb_seconds = executions * duration_seconds * memory_gb
    billable_gb_seconds = max(0.0, total_gb_seconds - free_tier_gb_seconds)
    compute_cost = billable_gb_seconds * price_per_gb_second
    
    return request_cost + compute_cost</code></pre>

                    <h5 class="mt-4">Tiered Pricing Helper</h5>
                    <p class="text-muted">Many services use tiered pricing. This helper function calculates costs across
                        tiers.</p>
                    <pre class="bg-dark text-light p-3 rounded"><code>def calculate_tiered_cost(
    usage: float,
    tiers: List[Dict[str, Any]]
) -> float:
    """
    Calculate cost using tiered pricing.
    
    Args:
        usage: Total usage units
        tiers: List of tier definitions, each with:
            - 'limit': Upper bound of tier (use float('inf') for unlimited)
            - 'price': Price per unit in this tier
    
    Returns:
        Total cost across all applicable tiers
    
    Example tiers:
        [
            {'limit': 1000000, 'price': 0.0},      # First 1M free
            {'limit': 10000000, 'price': 0.40},   # Next 9M at $0.40/M
            {'limit': float('inf'), 'price': 0.20} # Beyond at $0.20/M
        ]
    """
    total_cost = 0.0
    remaining = usage
    previous_limit = 0
    
    for tier in tiers:
        tier_limit = tier['limit']
        tier_price = tier['price']
        
        tier_size = tier_limit - previous_limit
        tier_usage = min(remaining, tier_size)
        
        total_cost += tier_usage * tier_price
        remaining -= tier_usage
        previous_limit = tier_limit
        
        if remaining <= 0:
            break
    
    return total_cost</code></pre>
                </div>
            </div>

            <!-- Testing -->
            <div class="card mb-4">
                <div class="card-header bg-secondary text-white">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-vial me-2"></i>Testing Pure Functions</h2>
                </div>
                <div class="card-body">
                    <p>
                        Pure functions are trivial to test because they have no dependencies or side effects.
                        Simply call the function with known inputs and assert the expected output.
                    </p>
                    <pre class="bg-dark text-light p-3 rounded"><code>import pytest
from calculation_v2.formulas.core_formulas import (
    calculate_messaging_cost,
    calculate_execution_cost
)

class TestMessagingCost:
    def test_basic_calculation(self):
        """Test basic messaging cost without free tier."""
        cost = calculate_messaging_cost(
            messages_per_month=1000000,
            message_size_kb=1.0,
            price_per_message=0.000001
        )
        assert cost == pytest.approx(1.0)
    
    def test_with_free_tier(self):
        """Test that free tier is correctly subtracted."""
        cost = calculate_messaging_cost(
            messages_per_month=2000000,
            message_size_kb=1.0,
            price_per_message=0.000001,
            free_tier_messages=1000000
        )
        assert cost == pytest.approx(1.0)
    
    def test_under_free_tier(self):
        """Test zero cost when usage is under free tier."""
        cost = calculate_messaging_cost(
            messages_per_month=500000,
            message_size_kb=1.0,
            price_per_message=0.000001,
            free_tier_messages=1000000
        )
        assert cost == 0.0

class TestExecutionCost:
    def test_lambda_calculation(self):
        """Test AWS Lambda-style pricing calculation."""
        cost = calculate_execution_cost(
            executions=1000000,
            duration_ms=100,
            memory_mb=128,
            price_per_request=0.0000002,
            price_per_gb_second=0.0000166667
        )
        # 1M requests * $0.0000002 = $0.20
        # 1M * 0.1s * 0.125GB = 12,500 GB-s * $0.0000166667 = $0.21
        assert cost == pytest.approx(0.41, rel=0.01)</code></pre>
                </div>
            </div>

            <!-- Extension Guide -->
            <div class="card mb-4">
                <div class="card-header bg-warning">
                    <h2 class="mb-0 h5"><i class="fa-solid fa-plus-circle me-2"></i>How to Extend</h2>
                </div>
                <div class="card-body">
                    <h5>Adding a New Formula</h5>
                    <ol>
                        <li>
                            <strong>Define the mathematical model</strong> — Write down the formula on paper first.
                            Identify all input variables and their units.
                        </li>
                        <li>
                            <strong>Create the function</strong> in <code>core_formulas.py</code>:
                            <pre class="bg-dark text-light p-3 rounded mt-2"><code>def calculate_new_service_cost(
    usage_param_1: float,
    usage_param_2: int,
    price_per_unit: float,
    free_tier: float = 0.0
) -> float:
    """
    Calculate [New Service] cost.
    
    Formula: cost = max(0, usage - free_tier) * price
    
    Args:
        usage_param_1: Description with units
        usage_param_2: Description with units
        price_per_unit: Cost per [unit]
        free_tier: Free monthly allowance
    
    Returns:
        Monthly cost in selected currency
    """
    billable = max(0, usage_param_1 - free_tier)
    return billable * price_per_unit</code></pre>
                        </li>
                        <li>
                            <strong>Write comprehensive tests</strong> covering:
                            <ul>
                                <li>Basic calculation with typical values</li>
                                <li>Edge cases (zero usage, very large values)</li>
                                <li>Free tier boundaries</li>
                                <li>Tiered pricing transitions (if applicable)</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Integrate with component calculators</strong> — Call your new formula from the
                            appropriate component calculator class.
                        </li>
                    </ol>

                    <div class="alert alert-info mt-3">
                        <i class="fa-solid fa-lightbulb me-1"></i>
                        <strong>Best Practice:</strong> Keep formulas small and focused. If a formula grows complex,
                        break it into smaller helper functions that can be composed together.
                    </div>
                </div>
            </div>

            <!-- Navigation -->
            <div class="d-flex justify-content-between mt-4">
                <a href="docs-patterns.html" class="btn btn-outline-secondary">
                    <i class="fa-solid fa-arrow-left me-2"></i>Back to Patterns Overview
                </a>
                <a href="docs-pattern-protocol.html" class="btn btn-primary">
                    Next: Protocol Pattern<i class="fa-solid fa-arrow-right ms-2"></i>
                </a>
            </div>

        </main>

    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <button id="backToTop" class="btn btn-primary rounded-circle position-fixed bottom-0 end-0 m-4 shadow fade p-3"
        style="display:none;">
        <i class="fa-solid fa-arrow-up"></i>
    </button>

    <script src="js/docs-nav.js" defer></script>
</body>

</html>