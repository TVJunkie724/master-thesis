import requests
import json
import copy
import traceback
from typing import Dict, Any, Optional, List, Iterable
from py.logger import logger
import py.constants as CONSTANTS
import py.config_loader as config_loader
from py.fetch_data import initial_fetch_azure

# -------------------------------------------------------------------
# Region mapping + defaults
# -------------------------------------------------------------------
def _load_azure_regions() -> Dict[str, str]:
    """
    Load Azure regions using the shared initial fetch logic (with caching).
    """
    return initial_fetch_azure.fetch_azure_regions()

AZURE_REGION_NAMES = _load_azure_regions()

# Fallback mapping for regions where Retail API might return empty or fail
REGION_FALLBACK = {
    "germanynorth": ["westeurope", "northeurope"],
    "francecentral": ["westeurope", "switzerlandnorth"],
    "germanywestcentral": ["westeurope", "northeurope"],
    "eastus": ["eastus2", "centralus", "westus"],
    "westus": ["westus2", "centralus", "eastus"],
    "centralus": ["eastus", "westus"],
}

RETAIL_API_BASE = "https://prices.azure.com/api/retail/prices"
HTTP_TIMEOUT = 12

STATIC_DEFAULTS_AZURE = {
    "transfer": {"egressPrice": 0.08},

    "iot": {
        "pricing_tiers": {
            "freeTier": {
                "limit": 240_000,      # 240k messages/month, 8k messages/day
                "threshold": 0,
                "price": 0
            },
            "tier1": {
                "limit": 120_000_000,      # 120 million
                "threshold": 12_000_000    # 12 million
            },
            "tier2": {
                "limit": 1_800_000_000,    # 1.8 billion
                "threshold": 180_000_000   # 180 million
            },
            "tier3": {
                "limit": "Infinity",
                "threshold": 1_800_000_000 # > 1.8 billion
            }
        }
    },
    "functions": {
        "requestPrice": 0.20,       # per million requests
        "durationPrice": 0.000016,  # per GB-second
        "freeRequests": 1_000_000,
        "freeComputeTime": 400_000
    },
    "storage_hot": {
        "readPrice": 0.25,    # per million reads (approx)
        "writePrice": 1.25,   # per million writes (approx)
        "storagePrice": 0.25,  # per GB/month
        "requestPrice": 0.0584,
        "minimumRequestUnits": 400,
        "RUsPerRead": 1,
        "RUsPerWrite": 10,
    },
    "storage_cool": {
        "storagePrice": 0.018,
        "writePrice": 0.10,
        "readPrice": 0.01,
        "dataRetrievalPrice": 0.01,
        "upfrontPrice": 0.0001,
    },
    "storage_archive": {
        "storagePrice": 0.00099,
        "writePrice": 0.10,
        "readPrice": 0.02,
        "dataRetrievalPrice": 0.02
    },
    "twinmaker": {
        "entityPrice": 0.50,
        "unifiedDataAccessAPICallsPrice": 0.0,
        "queryPrice": 0.0,
        "messagePrice": 0.000001,
        "operationPrice": 0.0000025,
        "queryUnitTiers": [
            {"lower": 1, "upper": 99, "value": 15}, 
            {"lower": 100, "upper": 9999, "value": 1500},
            {"lower": 10000, "value": 4000}
        ]
    },
    "grafana": {
        "editorPrice": 9.0,
        "viewerPrice": 5.0,
        "userPrice": 6.0,
        "hourlyPrice": 0.069
    }
}

# Service keywords configuration
AZURE_SERVICE_KEYWORDS = {
    "functions": {
        "serviceName": "Functions",
        "meters": {
            "requestPrice": {
                "meter_keywords": ["Total Executions"],
                "unit_keywords": ["10", "1 Million", "1M"],
            },
            "durationPrice": {
                "meter_keywords": ["Execution Time"],
                "unit_keywords": ["GB Second", "GiB Second", "GiB Hour"],
            },
        },
        "include": ["Standard", "Functions"],
        "exclude": [],
    },
    "transfer": {
        "serviceName": "Bandwidth",
        "meters": {
            "egressPrice": {
                "meter_keywords": ["Data Transfer Out"],
                "unit_keywords": ["GB"],
            },
        },
        "include": ["Bandwidth"],
        "exclude": ["China"],
    },
    "iot": {
        "serviceName": "IoT Hub",
        "tiers": {"S1": "tier1", "S2": "tier2", "S3": "tier3"},
        "include": ["IoT Hub"],
        "exclude": [],
    },
    "storage_hot": {
        "serviceName": "Azure Cosmos DB",
        "meters": {
            "storagePrice": {
                "meter_keywords": ["Standard Data Stored"],
                "unit_keywords": ["gb/month", "1 gb/month", "100 gb/month"],
            },
        },
        "include": ["Cosmos DB"],
        "exclude": [],
    },
    "storage_cool": {
        "serviceName": "Storage",
        "meters": {
            "storagePrice": {
                "meter_keywords": ["cool", "data stored"],
                "unit_keywords": ["gb/month", "1 gb/month", "100 gb/month"],
            },
            "writePrice": {
                "meter_keywords": ["cold lrs data write"],
                "unit_keywords": ["gb"],
            },
            "readPrice": {
                "meter_keywords": ["read"],
                "unit_keywords": ["gb"],
            },
            "dataRetrievalPrice": {
                "meter_keywords": ["cool data retrieval"],
                "unit_keywords": ["gb", "per gb"],
            },
        },
        "include": ["blob storage", "cool", "data stored"],
        "exclude": [
            "reserved", "ra-grs", "grs", "zrs",
            "operation", "transaction",
            "disk", "tables", "data lake",
        ],
    },
    "storage_archive": {
        "serviceName": "Storage",
        "meters": {
            "storagePrice": {
                "meter_keywords": ["archive", "data stored", "lrs"],
                "unit_keywords": ["gb/month", "1 gb/month", "100 gb/month"],
            },
            "writePrice": {
                "meter_keywords": ["Archive Data Write"],
                "unit_keywords": ["gb"],
            },
            "dataRetrievalPrice": {
                "meter_keywords": ["archive data retrieval"],
                "unit_keywords": ["gb", "per gb"],
            }
        },
        "include": ["blob storage", "archive", "data stored"],
        "exclude": [
            "reserved", "ra-grs", "grs", "zrs",
            "operation", "transaction",
            "disk", "tables", "data lake",
        ],
    },
    "twinmaker": {
        "serviceName": "Azure Digital Twins",
        "meters": {},
        "include": ["Digital Twins"],
        "exclude": [],
    },
    "grafana": {
        "serviceName": "Azure Managed Grafana",
        "meters": {},
        "include": ["Grafana"],
        "exclude": [],
    }
}


# -------------------------------------------------------------------
# Helper: Fetch from Retail API with pagination
# -------------------------------------------------------------------
def _fetch_azure_prices_api(filter_str, debug=False):
    """
    Query the Azure Retail Prices API with the given OData filter string.
    Handles pagination automatically.
    """
    items = []
    url = RETAIL_API_BASE
    params = {"$filter": filter_str}
    
    while url:
        try:
            resp = requests.get(url, params=params, timeout=HTTP_TIMEOUT)
            resp.raise_for_status()
            data = resp.json()
            items.extend(data.get("Items", []))
            url = data.get("NextPageLink")
            params = None # NextPageLink already contains params
        except Exception as e:
            logger.debug(f"‚ö†Ô∏è Azure API request failed: {e}")
            break
            
    return items


# -------------------------------------------------------------------
# Helper: Fetch with region fallback
# -------------------------------------------------------------------
def _iter_with_region_fallback(region: str, service_names, debug=False) -> List[Dict[str, Any]]:
    """Fetch Retail API rows for service(s), with region fallback."""
    region = region.lower()
    tried = []
    rows = []

    # Normalize to list
    if isinstance(service_names, str):
        service_names = [service_names]

    # Try primary region first, then fallbacks
    for r in [region] + REGION_FALLBACK.get(region, []):
        tried.append(r)

        service_filters = " or ".join([f"serviceName eq '{s}'" for s in service_names])
        odata_filter = f"armRegionName eq '{r}' and ({service_filters})"

        fetched = _fetch_azure_prices_api(odata_filter, debug)
        if fetched:
def _find_matching_row(
    rows: List[Dict[str, Any]],
    meter_keywords: List[str],
    unit_keywords: List[str],
    include_keywords: List[str],
    exclude_keywords: List[str],
    debug: bool
) -> Optional[Dict[str, Any]]:
    """Find best matching row based on keywords."""
    best = None

    for row in rows:
        product = (row.get("productName") or "").lower()
        meter = (row.get("meterName") or "").lower()
        unit = (row.get("unitOfMeasure") or "").lower()
        sku = (row.get("skuName") or "").lower()
        price = row.get("unitPrice")

        # Skip if price is None or 0
        if price is None or price == 0:
            continue

        # Exclude check
        exclude_found = any(
            ex in product or ex in meter or ex in sku
            for ex in exclude_keywords
        )
        if exclude_found or "reserved" in product or any(
            tier in product or tier in sku
            for tier in ["grs", "ra-grs", "zrs", "gzrs"]
        ):
            continue

        # Include check
        if include_keywords and not any(
            inc in product or inc in meter
            for inc in include_keywords
        ):
            continue

        # Meter keyword match
        if not any(mk in meter for mk in meter_keywords):
            continue

        # Unit keyword match
        if not any(uk in unit for uk in unit_keywords):
            continue

        # Best = lowest price
        if best is None or price < best.get("unitPrice", float('inf')):
            best = row
            if debug:
                logger.debug(f"   ‚úîÔ∏è Matched: {meter} @ {price} {row.get('currencyCode', 'USD')}")

    return best


# -------------------------------------------------------------------
# Specialized: IoT Hub (Tiered)
# -------------------------------------------------------------------
def _process_iot_hub(rows, neutral, debug=False):
    """Process IoT Hub tiered pricing."""
    defaults = STATIC_DEFAULTS_AZURE["iot"]
    tier_defaults = defaults["pricing_tiers"]

    result = {
        "pricing_tiers": {
            "freeTier": tier_defaults["freeTier"].copy()
        }
    }

    spec = AZURE_SERVICE_KEYWORDS[neutral]
    tier_map = spec["tiers"]

    for sku_label, tier_key in tier_map.items():
        matched_price = None

        for row in rows:
            sku = row.get("skuName") or ""
            meter = row.get("meterName") or ""

            if sku_label in sku and "unit" in meter.lower():
                price = row.get("unitPrice")
                if price and price > 0:
def _fetch_generic_meter_service(rows, neutral, spec, debug=False):
    """Fetch pricing for services with meter-based configuration."""
    result = {}
    include_kw = [x.lower() for x in spec.get("include", [])]
    exclude_kw = [x.lower() for x in spec.get("exclude", [])]

    for key, meter_config in spec.get("meters", {}).items():
        meter_kws = [mk.lower() for mk in meter_config["meter_keywords"]]
        unit_kws = [uk.lower() for uk in meter_config["unit_keywords"]]

        match = _find_matching_row(
            rows,
            meter_keywords=meter_kws,
            unit_keywords=unit_kws,
            include_keywords=include_kw,
            exclude_keywords=exclude_kw,
            debug=debug
        )

        if not match:
            if debug:
                logger.debug(f"   ‚ùå No match for {neutral}.{key}")
            continue

        price = match.get("unitPrice")
        unit_text = (match.get("unitOfMeasure") or "").lower()

        # Normalize pricing based on units
        normalized = price
        if "10" in unit_text:
            normalized = price * (1_000_000 / 10)
        elif "100" in unit_text:
            normalized = price * (1_000_000 / 100)

        result[key] = normalized

    return result


# -------------------------------------------------------------------
# Main Fetcher
# -------------------------------------------------------------------
def fetch_azure_price(service_name, region_code, debug=False):
    """
    Fetch pricing for a specific Azure service in a given region.
    Uses Azure Retail Prices API with service-specific configurations.
    """
    # Normalize service name
    neutral_service_name = service_name.lower().replace(" ", "_")
    
    region_human = AZURE_REGION_NAMES.get(region_code, region_code)
    
    # Check if we have config for this service
    spec = AZURE_SERVICE_KEYWORDS.get(neutral_service_name)
    if not spec:
        logger.warning(f"‚ö†Ô∏è No Azure config for service: {service_name}")
        return STATIC_DEFAULTS_AZURE.get(neutral_service_name, {})

    logger.info(f"üîç Fetching Azure {service_name} pricing for {region_human}...")

    # Fetch rows
    service_names = spec.get("serviceName")
    rows = _iter_with_region_fallback(region_code, service_names, debug)
    
    if not rows:
        logger.warning(f"‚ö†Ô∏è Failed to fetch Azure prices for {service_name} in {region_code}")
        return STATIC_DEFAULTS_AZURE.get(neutral_service_name, {})

    # Process based on service type
    if neutral_service_name == "iot":
        prices = _process_iot_hub(rows, neutral_service_name, debug)
    elif neutral_service_name in ["transfer", "grafana", "twinmaker"]:
        # For services without meter config, use static defaults
        prices = {}
    else:
        # Generic meter-based processing
        prices = _fetch_generic_meter_service(rows, neutral_service_name, spec, debug)

    # Merge with defaults
    defaults = STATIC_DEFAULTS_AZURE.get(neutral_service_name, {})
    final_prices = copy.deepcopy(defaults)
    final_prices.update(prices)
    
    if debug:
        logger.debug(f"   Final prices: {final_prices}")
    
    return final_prices