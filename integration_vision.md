# Project Vision: Twin2MultiCloud

## 1. The Core Vision
**Twin2MultiCloud** is a unified application designed to bridge the gap between theoretical cost optimization and practical multi-cloud infrastructure deployment.

It is not merely an integration of scripts, but a cohesive platform with two interfaces:
-   **CLI**: For automated pipelines and power users.
-   **Flutter Frontend**: For interactive scenario modeling and visualization.

## 2. Theoretical Foundation
The project is strictly based on the scientific framework defined in the paper:
> **EDT_25__CloudDT_engineering.pdf**

This paper establishes:
1.  **The 5-Layer Architecture**: The standard structure for a cloud-based Digital Twin (Data Acquisition, Processing, Storage, Management, Visualization).
2.  **Cost Formulas**: The mathematical models used to calculate and predict costs across AWS, Azure, and GCP.
3.  **Optimization Logic**: The algorithms for determining the most cost-effective provider distribution.

## 3. System Architecture

The system is composed of three distinct but interconnected projects:

### A. The Orchestrator: `twin2multicloud` (App)
*   **Role**: The central hub and user interface.
*   **Interfaces**:
    *   **CLI (`twin2multicloud_cli`)**: A Python-based command-line tool for executing optimization and deployment workflows.
    *   **Frontend (`twin2multicloud_flutter`)**: A cross-platform Flutter application that allows users to visually define twin parameters, view cost comparisons, and trigger deployments.
*   **Responsibility**: It consumes the "Brain" and controls the "Muscle". It holds the user session and configuration state.

### B. The Brain: `2-twin2clouds` (Optimizer)
*   **Role**: The calculation engine.
*   **Input**: Digital Twin scenario parameters (devices, messages/sec, storage retention).
*   **Logic**: Implements the cost formulas from `EDT_25__CloudDT_engineering.pdf`.
*   **Output**: A mathematically optimal multi-cloud configuration (e.g., "L1=GCP, L2=AWS...").
*   **Key Component**: `cloud_price_fetcher` modules that scrape/fetch real-time pricing to ensure the formulas use accurate variables.

### C. The Muscle: `3-cloud-deployer` (Deployer)
*   **Role**: The execution engine.
*   **Input**: The optimal configuration generated by the Brain (via the Orchestrator).
*   **Logic**: Infrastructure-as-Code (IaC) logic to provision resources.
*   **Output**: A fully functional, deployed Digital Twin infrastructure spanning multiple clouds.
*   **Key Feature**: Handles cross-cloud "plumbing" (e.g., setting up Pub/Sub to Lambda triggers) automatically.

## 4. The Workflow

1.  **Define**: User defines the scenario in the **Flutter App** (or CLI config).
2.  **Optimize**: The App calls the **Optimizer** (`2-twin2clouds`) to calculate the best path based on `EDT_25` formulas and real-time prices.
3.  **Review**: User reviews the predicted costs and recommended architecture in the App.
4.  **Deploy**: User clicks "Deploy". The App passes the configuration to the **Deployer** (`3-cloud-deployer`).
5.  **Execute**: The Deployer provisions the resources and returns the deployment status/endpoints to the App.

## 4. The Management Platform (Vision)

The ultimate goal is a unified **Flutter Application** that serves as the command center for the entire lifecycle of the digital twin.

### 4.1. Architecture: The "Management Layer"
To support the Flutter App, a persistent **Management Backend** is required (likely containerized alongside the deployer).
*   **Database:** Stores user profiles, cloud credentials, twin configurations, API keys, and deployment state.
*   **Authentication:** Handles User Login (OAuth via Google/Microsoft/University).
*   **Orchestrator:** Wraps the `3-cloud-deployer` API and the `Cost Optimizer`.

### 4.2. User Workflow
1.  **Configuration & Optimization:**
    *   User inputs requirements (data frequency, retention, etc.).
    *   **Data Fetching:** System fetches current cloud pricing and region mappings.
        *   **Live Logs:** App displays real-time status of price fetching (e.g., "Fetching AWS us-east-1 pricing...", "Updating Azure regions...").
    *   **Cost Optimizer** runs and proposes a multi-cloud architecture (e.g., "L1 in AWS, L2 in Azure").
    *   User reviews the proposal. Can manually override cloud choices (system warns if not cost-optimal).
2.  **Deployment:**
    *   User clicks "Deploy". (Or wants to separate deployment of layers and has the option to click on "Deploy L1", "Deploy L2", "Deploy L3", ...)
    *   **Live Logs:** The app streams real-time logs from the deployer (via WebSocket/Stream) to show progress.
3.  **Operation & Monitoring:**
    *   **Twin List:** User sees all deployed twins.
    *   **Dashboard:** Selecting a twin shows:
        *   **Live Status:** Health of each layer.
        *   **Error/Warning Log:** Real-time feed of system errors (e.g., "L2 Connector Timeout", "L1 Sensor Offline").
        *   **Visualization:** Embedded Grafana view or link.
        *   **Management:** Options to destroy or re-deploy specific layers to different clouds.
        *   **???Cost???:** Real-time cost calculation based on current usage???
        *   **???Billing???:** Real-time billing based on current usage???
        *   **Specifications:** Full list of all specifications/configs made by the user for the twin.

### 4.3. Error Handling Strategy
Errors must be captured at every layer and surfaced to the user.
*   **Sources:**
    *   **Ingestion (L1):** Malformed data, device disconnects.
    *   **Processing (L2):** Validation failures, cross-cloud connector timeouts.
    *   **Storage (L3):** Write failures, quota exceeded.
*   **Reporting:**
    *   Critical errors are published to a centralized **Error Notification Topic** (or API).
    *   The **Management Backend** subscribes to this topic and pushes alerts to the Flutter App.

## 5. Future Roadmap

-   **Unified API**: Expose the Optimizer and Deployer as microservices consumed by the Flutter App.
-   **Real-Time Feedback**: The App should display real-time status from the Cost Optimizer before calculation phase and Deployer during the provisioning phase.
-   **Paper Validation**: Use the App to gather real-world cost data from deployed twins to validate theoretical formulas.

## 6. References

For detailed technical information, please refer to the project documentation:

### 2-twin2clouds (Optimizer)
-   **[Documentation Overview](2-twin2clouds/docs/docs-overview.html)**
-   **[Architecture](2-twin2clouds/docs/docs-architecture.html)**
-   **[Cost Formulas](2-twin2clouds/docs/docs-formulas.html)**

### 3-cloud-deployer (Deployer)
-   **[Documentation Overview](3-cloud-deployer/docs/docs-overview.html)**
-   **[Architecture](3-cloud-deployer/docs/docs-architecture.html)**
-   **[Integration Guide](3-cloud-deployer/docs/docs-twin2clouds-integration.html)**
