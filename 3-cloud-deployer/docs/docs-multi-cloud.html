<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Multi-Cloud Deployment — Deployer Documentation</title>
    <link rel="icon" type="image/x-icon" href="references/favicon.ico">
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <link rel="stylesheet" href="css/docs_styles.css" />
</head>

<body>

    <div class="layout">
        <aside id="nav-placeholder"></aside>

        <main class="p-4">
            <h1 class="mb-3">
                <i class="fa-solid fa-cloud-arrow-up me-2"></i> Multi-Cloud Deployment Guide
            </h1>

            <p class="text-muted mb-4">
                Deploy Digital Twin layers across multiple cloud providers (AWS, Azure, GCP) with automatic cross-cloud
                communication.
            </p>

            <div class="callout info mb-4">
                <strong><i class="fa-solid fa-lightbulb me-2"></i>Overview</strong>
                Multi-cloud deployment enables distributing layers across different cloud providers while maintaining
                seamless data flow. For example: AWS IoT Core (L1) → Azure Functions (L2) → GCP Firestore (L3).
            </div>

            <!-- Table of Contents -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-solid fa-list me-2"></i>Table of Contents</h2>
                <div class="row">
                    <div class="col-md-6">
                        <h5>Configuration</h5>
                        <ul>
                            <li><a href="#provider-config">Provider Configuration</a></li>
                            <li><a href="#inter-cloud-config">Inter-Cloud Configuration</a></li>
                            <li><a href="#payload-envelope">Payload Envelope Format</a></li>
                            <li><a href="#authentication">Authentication (X-Inter-Cloud-Token)</a></li>
                        </ul>
                        <h5>Data Flow Patterns</h5>
                        <ul>
                            <li><a href="#universal-pattern">Universal Gluecode Pattern</a> ← Start here!</li>
                            <li><a href="#cross-cloud-flow">Cross-Cloud Data Flow (L1→L2→L3)</a></li>
                            <li><a href="#l3-storage-tiers">L3 Storage Tier Transfers</a></li>
                            <li><a href="#l3-l4-l5-access">L3→L4/L5 Data Access</a></li>
                        </ul>
                    </div>
                    <div class="col-md-6">
                        <h5>AWS Components</h5>
                        <ul>
                            <li><a href="#aws-components">AWS Multi-Cloud Components</a></li>
                            <li><a href="#deployment-order">Deployment Order</a></li>
                        </ul>
                        <h5>Reference</h5>
                        <ul>
                            <li><a href="#error-handling">Error Handling</a></li>
                            <li><a href="#security-future-work">Security Future Work</a> ← NEW</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Universal Pattern Section -->
            <div class="card mb-4" id="universal-pattern">
                <h2 class="mb-3"><i class="fa-solid fa-arrows-turn-right me-2"></i>Universal Gluecode Pattern</h2>

                <div class="callout tip mb-3">
                    <strong><i class="fa-solid fa-key me-2"></i>Key Insight</strong>
                    All multi-cloud gluecode follows the <strong>same universal pattern</strong>: a Connector/Requester
                    function sends data via HTTP POST with <code>X-Inter-Cloud-Token</code> to an
                    Ingestion/Writer/Reader
                    function on the target cloud.
                </div>

                <pre class="bg-dark text-light p-3 rounded mb-4"
                    style="font-family: 'Courier New', monospace; font-size: 0.85rem; overflow-x: auto;"><code>
┌────────────────────────────────────────────────────────────────────────────────┐
│                           UNIVERSAL GLUECODE PATTERN                           │
├────────────────────────────────────────────────────────────────────────────────┤
│                                                                                │
│   SOURCE CLOUD                                    TARGET CLOUD                 │
│   ┌─────────────────────────┐                    ┌─────────────────────────┐   │
│   │  Connector / Requester  │     HTTP POST      │  Ingestion / Writer /   │   │
│   │  ┌───────────────────┐  │                    │  Reader                 │   │
│   │  │ 1. Wrap payload   │  │    ┌──────────┐    │  ┌───────────────────┐  │   │
│   │  │ 2. Add X-Token    │──┼───►│  HTTPS   │────┼─►│ 1. Validate token │  │   │
│   │  │ 3. POST to URL    │  │    └──────────┘    │  │ 2. Process data   │  │   │
│   │  └───────────────────┘  │                    │  │ 3. Store/Forward  │  │   │
│   └─────────────────────────┘                    │  └───────────────────┘  │   │
│                                                  └─────────────────────────┘   │
│                                                                                │
│   Header: X-Inter-Cloud-Token: {shared_secret}                                 │
└────────────────────────────────────────────────────────────────────────────────┘
</code></pre>

                <h4>Pattern Usage by Layer</h4>
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Source Function</th>
                            <th>Target Function</th>
                            <th>Data Direction</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>L1 ≠ L2</td>
                            <td><strong>Connector</strong> (L1)</td>
                            <td><strong>Ingestion</strong> (L2)</td>
                            <td>IoT data → Processing</td>
                        </tr>
                        <tr>
                            <td>L2 ≠ L3</td>
                            <td><strong>Persister</strong> (L2)</td>
                            <td><strong>Writer</strong> (L3)</td>
                            <td>Processed data → Hot Storage</td>
                        </tr>
                        <tr>
                            <td>L3 Hot ≠ L3 Cold</td>
                            <td><strong>Hot-to-Cold Mover</strong></td>
                            <td><strong>Cold Writer</strong></td>
                            <td>Hot → Cold archival</td>
                        </tr>
                        <tr>
                            <td>L3 Cold ≠ L3 Archive</td>
                            <td><strong>Cold-to-Archive Mover</strong></td>
                            <td><strong>Archive Writer</strong></td>
                            <td>Cold → Archive archival</td>
                        </tr>
                        <tr>
                            <td>L3 ≠ L4</td>
                            <td><strong>DT Data Connector</strong> (L4)</td>
                            <td><strong>Hot Reader</strong> (L3)</td>
                            <td>Visualization ← Data query</td>
                        </tr>
                    </tbody>
                </table>

                <div class="callout info">
                    <strong><i class="fa-solid fa-circle-info me-2"></i>Single-Cloud vs Multi-Cloud</strong>
                    <p class="mb-0">In <strong>single-cloud</strong> scenarios (same cloud for adjacent layers), the
                        Connector/Requester function is <strong>not needed</strong>. The source function invokes the
                        target
                        directly. The pattern only applies when layers span different clouds.</p>
                </div>

                <div class="callout tip mt-3">
                    <strong><i class="fa-solid fa-code me-2"></i>Shared Module:
                        <code>_shared/inter_cloud.py</code></strong>
                    <p class="mb-0">All cross-cloud HTTP communication is centralized in the
                        <code>_shared/inter_cloud.py</code> module.
                        This provides consistent payload envelope building, exponential backoff retry logic, and token
                        validation
                        across all sender functions (Connector, Persister, Movers, DT Data Connector).
                    </p>
                </div>
            </div>

            <!-- Provider Configuration Section -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-solid fa-gear me-2"></i>Provider Configuration</h2>

                <p>All layer providers <strong>must</strong> be explicitly specified in
                    <code>config_providers.json</code>:
                </p>

                <pre class="bg-dark text-light p-3 rounded"><code>{
  "layer_1_provider": "aws",
  "layer_2_provider": "azure",
  "layer_3_hot_provider": "gcp",
  "layer_4_provider": "gcp",
  "layer_5_provider": "gcp"
}</code></pre>

                <div class="callout warning mt-3">
                    <strong><i class="fa-solid fa-triangle-exclamation me-2"></i>Required Configuration</strong>
                    All 5 layer providers are <strong>required</strong>. Missing provider configuration will cause a
                    <code>KeyError</code> at deployment time (fail-fast behavior).
                </div>
            </div>

            <!-- Cross-Cloud Data Flow Section -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-solid fa-arrows-rotate me-2"></i>Cross-Cloud Data Flow</h2>

                <p>When layers are on different clouds, special "gluecode" functions handle the cross-cloud
                    communication:</p>

                <!-- ASCII Flowchart -->
                <pre class="bg-dark text-light p-3 rounded mb-4"
                    style="font-family: 'Courier New', monospace; font-size: 0.85rem; overflow-x: auto;"><code>
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           MULTI-CLOUD DATA FLOW DECISION TREE                   │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ╔═══════════════════╗                                                          │
│  ║   IoT Device      ║                                                          │
│  ║   Publishes Data  ║                                                          │
│  ╚═════════╦═════════╝                                                          │
│            │                                                                    │
│            ▼                                                                    │
│  ┌─────────────────────┐                                                        │
│  │  L1: DISPATCHER     │                                                        │
│  │  (IoT Core Topic)   │                                                        │
│  └──────────┬──────────┘                                                        │
│             │                                                                   │
│             ▼                                                                   │
│  ╔══════════════════════════════════════════════════════════════════════╗       │
│  ║  IS L2 ON SAME CLOUD AS L1?                                          ║       │
│  ╚══════════════════════════════════════════════════════════════════════╝       │
│             │                                                                   │
│     ┌───────┴───────┐                                                           │
│     │               │                                                           │
│     ▼ YES           ▼ NO                                                        │
│  ┌──────────┐    ┌──────────────────────────────────────────────────────────┐   │
│  │ L1:      |    |  L1:                                                     |   |
|  | INVOKE   │    │  INVOKE CONNECTOR                                        │   │
│  │ LOCAL    │    │  (wraps event, POSTs to REMOTE_INGESTION_URL)            │   │
│  │ PROCESSOR│    │                                                          │   │
│  └────┬─────┘    │       ┌────────────────────────────────────┐             │   │
│       │          │       │  HTTP POST with X-Inter-Cloud-Token│             │   │
│       │          │       └──────────────┬─────────────────────┘             │   │
│       │          │                      │                                   │   │
│       │          │                      ▼                                   │   │
│       │          │           ┌─────────────────────┐                        │   │
│       │          │           │  L2 INGESTION       │ (on remote cloud)      │   │
│       │          │           │  - Validates token  │                        │   │
│       │          │           │  - Invokes processor│                        │   │
│       │          │           └──────────┬──────────┘                        │   │
│       │          └──────────────────────┼───────────────────────────────────┘   │
│       │                                 │                                       │
│       └─────────────┬───────────────────┘                                       │
│                     │                                                           │
│                     ▼                                                           │
│          ┌─────────────────────┐                                                │
│          │  L2: PROCESSOR      │                                                │
│          │  (validates, cleans)│                                                │
│          └──────────┬──────────┘                                                │
│                     │                                                           │
│                     ▼                                                           │
│          ┌─────────────────────┐                                                │
│          │  L2: PERSISTER      │                                                │
│          └──────────┬──────────┘                                                │
│                     │                                                           │
│  ╔══════════════════════════════════════════════════════════════════════╗       │
│  ║  IS L3 ON SAME CLOUD AS L2?                                          ║       │
│  ╚══════════════════════════════════════════════════════════════════════╝       │
│                     │                                                           │
│     ┌───────────────┴───────────────┐                                           │
│     │                               │                                           │
│     ▼ YES                           ▼ NO                                        │
│  ┌──────────────┐         ┌──────────────────────────────────────────────────┐  │
|  | L2:          |         |  L2:                                             |  │
│  │ WRITE TO     │         │  POST TO REMOTE_WRITER_URL                       │  │
│  │ LOCAL DB     │         │  (with X-Inter-Cloud-Token)                      │  │
│  │ (DynamoDB,   │         │                                                  │  │
│  │  Cosmos,     │         │       ┌────────────────────────────────────┐     │  │
│  │  Firestore)  │         │       │  HTTP POST with X-Inter-Cloud-Token│     │  │
│  └──────┬───────┘         │       └──────────────┬─────────────────────┘     │  │
│         │                 │                      │                           │  │
│         │                 │                      ▼                           │  │
│         │                 │           ┌─────────────────────┐                │  │
│         │                 │           │  L3 WRITER          │ (on L3 cloud)  │  │
│         │                 │           │  - Validates token  │                │  │
│         │                 │           │  - Writes to DB     │                │  │
│         │                 │           └──────────┬──────────┘                │  │
│         │                 └──────────────────────┼───────────────────────────┘  │
│         │                                        │                              │
│         └────────────────┬───────────────────────┘                              │
│                          │                                                      │
│                          ▼                                                      │
│               ╔════════════════════╗                                            │
│               ║   DATA PERSISTED   ║                                            │
│               ║   IN HOT STORAGE   ║                                            │
│               ╚════════════════════╝                                            │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
Legend:  ─────►  = Function invoke or HTTP POST with X-Inter-Cloud-Token</code></pre>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Component</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>L1 ≠ L2</td>
                            <td><strong>Connector</strong> (L1) → <strong>Ingestion</strong> (L2)</td>
                            <td>Connector POSTs to Ingestion's Function URL</td>
                        </tr>
                        <tr>
                            <td>L2 ≠ L3</td>
                            <td><strong>Persister</strong> (L2) → <strong>Writer</strong> (L3)</td>
                            <td>Persister POSTs to Writer's Function URL</td>
                        </tr>
                        <tr>
                            <td>L3 ≠ L4/L5</td>
                            <td><strong>API Gateway</strong> (L3)</td>
                            <td>HTTP endpoints for remote L4/L5 access</td>
                        </tr>
                        <tr>
                            <td>L3 Hot ≠ L3 Cold</td>
                            <td><strong>Hot-to-Cold Mover</strong> → <strong>Cold Writer</strong></td>
                            <td>Mover POSTs chunked data (≤5MB) to Cold Writer</td>
                        </tr>
                        <tr>
                            <td>L3 Cold ≠ L3 Archive</td>
                            <td><strong>Cold-to-Archive Mover</strong> → <strong>Archive Writer</strong></td>
                            <td>Mover POSTs data to Archive Writer</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- L3 Mover Multi-Cloud Section -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-solid fa-arrows-alt-h me-2"></i>L3 Storage Tier Transfers</h2>

                <p>When L3 storage tiers (Hot, Cold, Archive) span different clouds, dedicated
                    <strong>Writer</strong> Lambdas enable cross-cloud data movement:
                </p>

                <pre class="bg-dark text-light p-3 rounded" style="overflow-x: auto; font-size: 0.75rem;"><code>
┌──────────────────────────────────────────────────────────────────────────────────────┐
│                           MULTI-CLOUD L3 MOVER FLOW                                  │
├──────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│  AWS L3 Hot (DynamoDB)             Azure L3 Cold              GCP L3 Archive         │
│  ┌──────────────┐                  ┌──────────────┐          ┌──────────────┐        │
│  │   DynamoDB   │                  │ Blob Storage │          │Cloud Storage │        │
│  │  (Hot Data)  │                  │   (Cool)     │          │ (Coldline)   │        │
│  └──────┬───────┘                  └──────┬───────┘          └──────────────┘        │
│         │                                 ▲                         ▲                │
│         │ EventBridge                     │                         │                │
│         │ (Scheduled)           HTTP POST (chunked)       HTTP POST (chunked)        │
│         ▼                                 │                         │                │
│  ┌───────────────────┐             ┌──────────────┐          ┌──────────────┐        │
│  │ Hot-to-Cold Mover │──HTTP─────▶ │ Cold Writer  │          │Archive Writer│        │
│  │ (AWS Lambda)      │  POST       │ (Azure Func) │          │(GCP CloudFn) │        │
│  │                   │ ≤5MB        │ - Auth token │          │ - Auth token │        │
│  │ - Query DynamoDB  │ chunks      │ - Write Blob │          │ - Write GCS  │        │
│  │ - Chunk ≤5MB      │             └──────────────┘          └──────────────┘        │
│  │ - POST to Writer  │                    │                         ▲                │
│  │ - Delete from DDB │                    │                         │                │
│  └───────────────────┘                    ▼                         │                │
│                                    ┌───────────────────┐            │                │
│                                    │ Cold-to-Arch Mover│──HTTP POST─┘                │
│                                    │ (Azure Function)  │   ≤5MB chunks               │
│                                    │ - List blobs      │                             │
│                                    │ - Read/chunk data │                             │
│                                    │ - POST to Archive │                             │
│                                    │ - Delete blob     │                             │
│                                    └───────────────────┘                             │
│                                                                                      │
└──────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>

                <div class="callout tip mt-3 mb-3">
                    <strong><i class="fa-solid fa-bolt me-2"></i>5MB Chunk Optimization</strong>
                    <p class="mb-0">All cross-cloud transfers use ≤5MB chunks to stay within AWS Lambda's 6MB payload
                        limit
                        while reducing S3 PUT costs by ~80% compared to per-item transfers.</p>
                </div>

                <h4>L3 Writer Components</h4>
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Component</th>
                            <th>Triggered By</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Cold Writer</code></td>
                            <td>Remote Hot-to-Cold Mover</td>
                            <td>Receives chunked data, writes to Cold storage (S3 STANDARD_IA)</td>
                        </tr>
                        <tr>
                            <td><code>Archive Writer</code></td>
                            <td>Remote Cold-to-Archive Mover</td>
                            <td>Receives data, writes to Archive storage (S3 DEEP_ARCHIVE)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- L3→L4 Data Access Section -->
            <div class="card mb-4" id="l3-l4-l5-access">
                <h2 class="mb-3"><i class="fa-solid fa-database me-2"></i>L3→L4/L5 Data Access</h2>

                <p>When L4 (Twin Management) or L5 (Visualization) are on a different cloud than L3 (Storage),
                    the <strong>Digital Twin Data Connector</strong> queries storage via HTTP:
                </p>

                <pre class="bg-dark text-light p-3 rounded" style="overflow-x: auto; font-size: 0.75rem;"><code>
┌──────────────────────────────────────────────────────────────────────────────────────┐
│                         MULTI-CLOUD L3→L4 DATA ACCESS FLOW                           │
├──────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                      │
│  Azure L4 (TwinMaker)                             AWS L3 (Storage)                   │
│  ┌──────────────────────────┐                     ┌──────────────────────────┐       │
│  │     IoT TwinMaker        │                     │        DynamoDB          │       │
│  │   ┌─────────────────┐    │                     │      (Hot Storage)       │       │
│  │   │ Digital Twin    │    │                     └───────────┬──────────────┘       │
│  │   │ Entity/Component│    │                                 │                      │
│  │   └────────┬────────┘    │                                 │                      │
│  │            │             │                                 │                      │
│  │      Query │ Data        │                                 │                      │
│  │            ▼             │                                 │                      │
│  │   ┌─────────────────┐    │                     ┌───────────┴──────────────┐       │
│  │   │ DT Data         │────┼──HTTP POST─────────►│     Hot Reader Lambda    │       │
│  │   │ Connector       │    │  X-Inter-Cloud-Token│    ┌─────────────────┐   │       │
│  │   │ (Azure Function)│◄───┼──────────────────────│    │ Query DynamoDB  │   │       │
│  │   │                 │    │   JSON Response      │    │ Return Results  │   │       │
│  │   └─────────────────┘    │                     │    └─────────────────┘   │       │
│  │                          │                     │                          │       │
│  └──────────────────────────┘                     │    Lambda Function URL   │       │
│                                                   │  (Public w/ Token Auth)  │       │
│                                                   └──────────────────────────┘       │
│                                                                                      │
└──────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>

                <h4>L3→L4 Components</h4>
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Component</th>
                            <th>Location</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>DT Data Connector</code></td>
                            <td>L4 (TwinMaker)</td>
                            <td>Routes queries: local Hot Reader or remote Function URL</td>
                        </tr>
                        <tr>
                            <td><code>Hot Reader</code></td>
                            <td>L3 (Storage)</td>
                            <td>Queries DynamoDB, returns telemetry data for TwinMaker</td>
                        </tr>
                        <tr>
                            <td><code>Hot Reader Last Entry</code></td>
                            <td>L3 (Storage)</td>
                            <td>Returns only the most recent entry per device</td>
                        </tr>
                    </tbody>
                </table>

                <div class="callout info mt-3">
                    <strong><i class="fa-solid fa-circle-info me-2"></i>Function URLs Replace API Gateway</strong>
                    <p class="mb-0">Lambda Function URLs provide public HTTP endpoints without API Gateway overhead.
                        Security is handled by token validation in the Lambda code (<code>X-Inter-Cloud-Token</code>).
                    </p>
                </div>
            </div>

            <!-- Inter-Cloud Configuration Section -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-solid fa-link me-2"></i>Inter-Cloud Configuration</h2>

                <p>Cross-cloud connections are configured in <code>config_inter_cloud.json</code>:</p>

                <pre class="bg-dark text-light p-3 rounded"><code>{
  "expected_token": "your-secure-token-here",
  "connections": {
    "aws_l2_to_azure_l3": {
      "url": "https://azure-writer-func.azurewebsites.net/api/writer",
      "token": "your-secure-token-here"
    },
    "gcp_l1_to_aws_l2": {
      "url": "https://abc123.lambda-url.us-east-1.on.aws/",
      "token": "your-secure-token-here"
    }
  }
}</code></pre>

                <h4 class="mt-3">Configuration Fields</h4>
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Field</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>expected_token</code></td>
                            <td>Token this deployment expects to receive (for Ingestion/Writer validation)</td>
                        </tr>
                        <tr>
                            <td><code>connections.{id}.url</code></td>
                            <td>Target endpoint URL for cross-cloud POSTs</td>
                        </tr>
                        <tr>
                            <td><code>connections.{id}.token</code></td>
                            <td>Token to send when POSTing to the target</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Payload Envelope Section -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-solid fa-envelope me-2"></i>Inter-Cloud Payload Envelope</h2>

                <p>All cross-cloud messages use a standardized envelope format:</p>

                <pre class="bg-dark text-light p-3 rounded"><code>{
  "source_cloud": "aws",
  "target_layer": "L2",
  "message_type": "telemetry",
  "timestamp": "2024-12-10T11:30:00.000Z",
  "trace_id": "550e8400-e29b-41d4-a716-446655440000",
  "payload": { /* original device data */ }
}</code></pre>

                <h4 class="mt-3">Envelope Fields</h4>
                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Field</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>source_cloud</code></td>
                            <td>string</td>
                            <td>Originating cloud provider (aws, azure, gcp)</td>
                        </tr>
                        <tr>
                            <td><code>target_layer</code></td>
                            <td>string</td>
                            <td>Destination layer (L2, L3)</td>
                        </tr>
                        <tr>
                            <td><code>message_type</code></td>
                            <td>string</td>
                            <td>Type of message (telemetry, command, etc.)</td>
                        </tr>
                        <tr>
                            <td><code>timestamp</code></td>
                            <td>string</td>
                            <td>ISO 8601 UTC timestamp</td>
                        </tr>
                        <tr>
                            <td><code>trace_id</code></td>
                            <td>string</td>
                            <td>UUID for request tracing across clouds</td>
                        </tr>
                        <tr>
                            <td><code>payload</code></td>
                            <td>object</td>
                            <td>Original device/event data</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Authentication Section -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-solid fa-shield-halved me-2"></i>Authentication</h2>

                <p>Cross-cloud requests use a standardized token-based authentication:</p>

                <pre class="bg-dark text-light p-3 rounded"><code>POST /ingestion HTTP/1.1
Host: target-function.cloud.provider
Content-Type: application/json
X-Inter-Cloud-Token: your-secure-token-here

{ /* envelope payload */ }</code></pre>

                <div class="callout info mt-3">
                    <strong><i class="fa-solid fa-key me-2"></i>Token Validation</strong>
                    The receiving function (Ingestion/Writer) validates the <code>X-Inter-Cloud-Token</code> header
                    against its <code>INTER_CLOUD_TOKEN</code> environment variable. Invalid tokens result in HTTP 401.
                </div>
            </div>

            <!-- AWS-Specific Components Section -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-brands fa-aws me-2"></i>AWS Multi-Cloud Components</h2>

                <h4>Ingestion (L2 - when L1 is remote)</h4>
                <p>Deployed automatically when <code>layer_1_provider ≠ layer_2_provider</code>:</p>
                <ul>
                    <li>Lambda function with Function URL</li>
                    <li>Validates <code>X-Inter-Cloud-Token</code></li>
                    <li>Invokes local Persister Lambda</li>
                </ul>

                <h4 class="mt-3">Writer (L3 - when L2 is remote)</h4>
                <p>Deployed automatically when <code>layer_2_provider ≠ layer_3_hot_provider</code>:</p>
                <ul>
                    <li>Lambda function with Function URL</li>
                    <li>Validates <code>X-Inter-Cloud-Token</code></li>
                    <li>Writes directly to DynamoDB</li>
                </ul>

                <h4 class="mt-3">Connector (L1 - when L2 is remote)</h4>
                <p>Replaces Processor when <code>layer_1_provider ≠ layer_2_provider</code>:</p>
                <ul>
                    <li>POSTs envelope to remote Ingestion URL</li>
                    <li>Includes <code>X-Inter-Cloud-Token</code> header</li>
                    <li>Retry logic with exponential backoff</li>
                </ul>

                <h4 class="mt-3">Persister (L2 - when L3 is remote)</h4>
                <p>Enhanced when <code>layer_2_provider ≠ layer_3_hot_provider</code>:</p>
                <ul>
                    <li>POSTs envelope to remote Writer URL</li>
                    <li>Dual validation (env var + config_providers check)</li>
                    <li>Retry logic with exponential backoff</li>
                </ul>
            </div>

            <!-- Deployment Order Section -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-solid fa-list-ol me-2"></i>Multi-Cloud Deployment Order</h2>

                <p>For multi-cloud deployments, deploy layers in order by dependency:</p>

                <ol>
                    <li><strong>Deploy L3 first</strong> (on target cloud) - to get Writer Function URL</li>
                    <li>Update <code>config_inter_cloud.json</code> with Writer URL</li>
                    <li><strong>Deploy L2</strong> (on target cloud) - to get Ingestion Function URL</li>
                    <li>Update <code>config_inter_cloud.json</code> with Ingestion URL</li>
                    <li><strong>Deploy L1</strong> (on source cloud) - Connectors will use the URLs</li>
                    <li><strong>Deploy L4/L5</strong> (on target cloud)</li>
                </ol>

                <div class="callout warning mt-3">
                    <strong><i class="fa-solid fa-triangle-exclamation me-2"></i>Important</strong>
                    URLs are generated at deployment time. You must deploy the receiving layer first, then update
                    <code>config_inter_cloud.json</code> before deploying the sending layer.
                </div>
            </div>

            <!-- Error Handling Section -->
            <div class="card mb-4">
                <h2 class="mb-3"><i class="fa-solid fa-bug me-2"></i>Error Handling</h2>

                <table class="table table-striped">
                    <thead>
                        <tr>
                            <th>Error</th>
                            <th>Cause</th>
                            <th>Resolution</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>KeyError: layer_X_provider</code></td>
                            <td>Missing provider in config_providers.json</td>
                            <td>Add missing layer provider to config</td>
                        </tr>
                        <tr>
                            <td><code>ValueError: Multi-cloud config incomplete</code></td>
                            <td>Missing URL or token in config_inter_cloud.json</td>
                            <td>Add connection details for the layer pair</td>
                        </tr>
                        <tr>
                            <td>HTTP 401 from Ingestion/Writer</td>
                            <td>Token mismatch</td>
                            <td>Ensure tokens match in source and target configs</td>
                        </tr>
                        <tr>
                            <td><code>ConfigurationError: config_providers missing</code></td>
                            <td>DIGITAL_TWIN_INFO doesn't include config_providers</td>
                            <td>Redeploy Lambda with updated deployer</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Security Future Work Section -->
            <div class="card mb-4" id="security-future-work">
                <h2 class="mb-3"><i class="fa-solid fa-shield-halved me-2"></i>Security Future Work</h2>

                <div class="callout warning mb-4">
                    <strong><i class="fa-solid fa-triangle-exclamation me-2"></i>Current Security Limitation</strong>
                    <p class="mb-0">The current multi-cloud implementation uses a simple shared secret token
                        (<code>X-Inter-Cloud-Token</code>) for authentication. While functional, this approach has
                        security limitations compared to enterprise-grade API management solutions.</p>
                </div>

                <h3>Current Approach vs. API Gateway</h3>
                <table class="table table-bordered">
                    <thead class="table-dark">
                        <tr>
                            <th>Feature</th>
                            <th>Current (X-Token)</th>
                            <th>API Gateway</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Authentication</strong></td>
                            <td>Simple shared secret in header</td>
                            <td>OAuth 2.0, JWT, API Keys, Lambda authorizers, mTLS</td>
                        </tr>
                        <tr>
                            <td><strong>Token Validation</strong></td>
                            <td>String comparison in Lambda code</td>
                            <td>Cryptographic JWT signature validation</td>
                        </tr>
                        <tr>
                            <td><strong>Token Expiration</strong></td>
                            <td>None (static token)</td>
                            <td>Built-in expiration claims (<code>exp</code>, <code>nbf</code>)</td>
                        </tr>
                        <tr>
                            <td><strong>Rate Limiting</strong></td>
                            <td>None</td>
                            <td>Built-in throttling per IP/API key</td>
                        </tr>
                        <tr>
                            <td><strong>DDoS Protection</strong></td>
                            <td>None</td>
                            <td>Built-in, AWS Shield integration</td>
                        </tr>
                        <tr>
                            <td><strong>WAF Integration</strong></td>
                            <td>None</td>
                            <td>AWS WAF, Azure WAF, Cloud Armor</td>
                        </tr>
                        <tr>
                            <td><strong>Request Validation</strong></td>
                            <td>Custom code in Lambda</td>
                            <td>Schema validation at gateway level</td>
                        </tr>
                        <tr>
                            <td><strong>Audit Logging</strong></td>
                            <td>CloudWatch (if configured)</td>
                            <td>Comprehensive access logs, CloudTrail</td>
                        </tr>
                    </tbody>
                </table>

                <h3 class="mt-4">Recommended Security Enhancements</h3>

                <!-- Enhancement 1: API Gateway -->
                <div class="card bg-dark mb-3">
                    <div class="card-header"><strong>1. API Gateway with OAuth 2.0 / JWT</strong></div>
                    <div class="card-body">
                        <p><strong>Why it's more secure:</strong></p>
                        <ul>
                            <li>Cryptographic token validation instead of string comparison</li>
                            <li>Tokens have built-in expiration (short-lived access tokens)</li>
                            <li>Tokens are signed by an identity provider (cannot be forged)</li>
                            <li>Gateway validates tokens <em>before</em> invoking the Lambda (early rejection)</li>
                            <li>Built-in rate limiting and DDoS protection</li>
                        </ul>

                        <p><strong>Architecture change:</strong></p>
                        <pre class="bg-dark text-light p-3 rounded" style="font-size: 0.8rem;"><code>CURRENT:
  Connector → HTTPS + X-Token → Function URL → Ingestion

PROPOSED:
  Connector → HTTPS + JWT → API Gateway → (validate JWT) → Ingestion</code></pre>
                    </div>
                </div>

                <!-- Enhancement 2: mTLS -->
                <div class="card bg-dark mb-3">
                    <div class="card-header"><strong>2. Mutual TLS (mTLS)</strong></div>
                    <div class="card-body">
                        <p><strong>Why it's more secure:</strong></p>
                        <ul>
                            <li>Two-way certificate authentication (both client and server verify each other)</li>
                            <li>Prevents man-in-the-middle attacks even if HTTPS is bypassed</li>
                            <li>Certificate-based identity is harder to spoof than tokens</li>
                        </ul>
                        <p><strong>Trade-off:</strong> Higher certificate management overhead</p>
                    </div>
                </div>

                <!-- Enhancement 3: Token Rotation -->
                <div class="card bg-dark mb-3">
                    <div class="card-header"><strong>3. Automated Token Rotation</strong></div>
                    <div class="card-body">
                        <p><strong>Why it's more secure:</strong></p>
                        <ul>
                            <li>Limits damage window if a token is compromised</li>
                            <li>Short-lived tokens (15-60 minutes) with refresh mechanism</li>
                            <li>Tokens stored in secret managers (AWS Secrets Manager, Azure Key Vault)</li>
                        </ul>
                    </div>
                </div>

                <h3 class="mt-4">Implementation Guide: API Gateway Migration</h3>

                <!-- AWS Implementation -->
                <h4><i class="fa-brands fa-aws me-2"></i>AWS Implementation Steps</h4>
                <ol>
                    <li>
                        <strong>Create API Gateway (HTTP API type)</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># Using AWS CLI
aws apigatewayv2 create-api \
  --name "digital-twin-api" \
  --protocol-type HTTP \
  --target arn:aws:lambda:REGION:ACCOUNT:function:ingestion</code></pre>
                    </li>
                    <li>
                        <strong>Configure JWT Authorizer</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># Create authorizer with Cognito or any OIDC provider
aws apigatewayv2 create-authorizer \
  --api-id API_ID \
  --authorizer-type JWT \
  --name "jwt-authorizer" \
  --identity-source "$request.header.Authorization" \
  --jwt-configuration '{
    "Issuer": "https://cognito-idp.REGION.amazonaws.com/USER_POOL_ID",
    "Audience": ["your-client-id"]
  }'</code></pre>
                    </li>
                    <li>
                        <strong>Attach Authorizer to Route</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code>aws apigatewayv2 update-route \
  --api-id API_ID \
  --route-id ROUTE_ID \
  --authorization-type JWT \
  --authorizer-id AUTHORIZER_ID</code></pre>
                    </li>
                    <li>
                        <strong>Update Connector to Obtain JWT</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># In connector Lambda, obtain token from Cognito
import boto3

cognito = boto3.client('cognito-idp')
response = cognito.initiate_auth(
    ClientId='your-client-id',
    AuthFlow='CLIENT_CREDENTIALS',
    AuthParameters={
        'client_id': 'your-client-id',
        'client_secret': 'your-client-secret'
    }
)
jwt_token = response['AuthenticationResult']['AccessToken']

# Send request with JWT
headers = {'Authorization': f'Bearer {jwt_token}'}</code></pre>
                    </li>
                    <li>
                        <strong>Enable WAF and Rate Limiting</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># Attach WAF to API Gateway
aws wafv2 associate-web-acl \
  --web-acl-arn arn:aws:wafv2:REGION:ACCOUNT:regional/webacl/NAME/ID \
  --resource-arn arn:aws:apigateway:REGION::/restapis/API_ID/stages/STAGE</code></pre>
                    </li>
                </ol>

                <!-- Azure Implementation -->
                <h4 class="mt-4"><i class="fa-brands fa-microsoft me-2"></i>Azure Implementation Steps</h4>
                <ol>
                    <li>
                        <strong>Register API Application in Microsoft Entra ID</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># Create App Registration for the API (target)
az ad app create \
  --display-name "digital-twin-api" \
  --identifier-uris "api://digital-twin-api" \
  --sign-in-audience "AzureADMyOrg"

# Note the Application (client) ID from output
# Example: "appId": "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"</code></pre>
                    </li>
                    <li>
                        <strong>Register Client Application (Connector)</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># Create App Registration for the client (source/connector)
az ad app create \
  --display-name "digital-twin-connector" \
  --sign-in-audience "AzureADMyOrg"

# Create client secret
az ad app credential reset \
  --id CLIENT_APP_ID \
  --append \
  --years 2

# Note the password (client_secret) from output</code></pre>
                    </li>
                    <li>
                        <strong>Grant API Permissions to Client</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># Grant the connector app permission to call the API
az ad app permission add \
  --id CLIENT_APP_ID \
  --api API_APP_ID \
  --api-permissions "access_as_application=Role"

# Admin consent for the permission
az ad app permission admin-consent --id CLIENT_APP_ID</code></pre>
                    </li>
                    <li>
                        <strong>Create API Management Instance</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># Using Azure CLI
az apim create \
  --name "digital-twin-apim" \
  --resource-group "rg-digital-twin" \
  --publisher-email "admin@example.com" \
  --publisher-name "DigitalTwin" \
  --sku-name "Consumption"</code></pre>
                    </li>
                    <li>
                        <strong>Import Function App as API</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code>az apim api import \
  --path "ingestion" \
  --resource-group "rg-digital-twin" \
  --service-name "digital-twin-apim" \
  --specification-format OpenApiJson \
  --specification-url "https://your-function.azurewebsites.net/api/openapi.json"</code></pre>
                    </li>
                    <li>
                        <strong>Add JWT Validation Policy (validate-azure-ad-token)</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code>&lt;!-- Add to inbound policy section in APIM --&gt;
&lt;validate-azure-ad-token tenant-id="YOUR_TENANT_ID"&gt;
  &lt;client-application-ids&gt;
    &lt;application-id&gt;CLIENT_APP_ID&lt;/application-id&gt;
  &lt;/client-application-ids&gt;
  &lt;audiences&gt;
    &lt;audience&gt;api://digital-twin-api&lt;/audience&gt;
  &lt;/audiences&gt;
&lt;/validate-azure-ad-token&gt;</code></pre>
                    </li>
                    <li>
                        <strong>Update Connector to Obtain Entra ID Token</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># In connector Azure Function, obtain token using Client Credentials flow
import requests

def get_entra_token():
    token_url = f"https://login.microsoftonline.com/{TENANT_ID}/oauth2/v2.0/token"
    response = requests.post(token_url, data={
        "client_id": CLIENT_APP_ID,
        "client_secret": CLIENT_SECRET,
        "scope": "api://digital-twin-api/.default",
        "grant_type": "client_credentials"
    })
    return response.json()["access_token"]

# Send request with JWT
headers = {"Authorization": f"Bearer {get_entra_token()}"}</code></pre>
                    </li>
                    <li>
                        <strong>Enable Rate Limiting and Quotas</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code>&lt;rate-limit calls="100" renewal-period="60"/&gt;
&lt;quota calls="10000" renewal-period="86400"/&gt;</code></pre>
                    </li>
                </ol>

                <!-- GCP Implementation -->
                <h4 class="mt-4"><i class="fa-brands fa-google me-2"></i>GCP Implementation Steps</h4>
                <ol>
                    <li>
                        <strong>Create API Gateway Config</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># openapi-spec.yaml
swagger: '2.0'
info:
  title: Digital Twin API
  version: 1.0.0
schemes: [https]
x-google-backend:
  address: https://REGION-PROJECT.cloudfunctions.net/ingestion
securityDefinitions:
  jwt_auth:
    authorizationUrl: ""
    flow: "implicit"
    type: "oauth2"
    x-google-issuer: "https://accounts.google.com"
    x-google-audiences: "your-client-id"
security:
  - jwt_auth: []</code></pre>
                    </li>
                    <li>
                        <strong>Deploy API Gateway</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code># Create API config
gcloud api-gateway api-configs create digital-twin-config \
  --api=digital-twin-api \
  --openapi-spec=openapi-spec.yaml

# Create gateway
gcloud api-gateway gateways create digital-twin-gateway \
  --api=digital-twin-api \
  --api-config=digital-twin-config \
  --location=us-central1</code></pre>
                    </li>
                    <li>
                        <strong>Enable Cloud Armor for DDoS Protection</strong>
                        <pre class="bg-secondary text-light p-2 rounded mt-2"><code>gcloud compute security-policies create api-security-policy \
  --description "API Gateway protection"

gcloud compute security-policies rules create 1000 \
  --security-policy api-security-policy \
  --expression "evaluatePreconfiguredExpr('xss-stable')" \
  --action deny-403</code></pre>
                    </li>
                </ol>

                <!-- Code Changes Required -->
                <h3 class="mt-4">Code Changes Required</h3>
                <table class="table table-sm">
                    <thead>
                        <tr>
                            <th>File</th>
                            <th>Change</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>connector/lambda_function.py</code></td>
                            <td>Obtain JWT from identity provider instead of using static token</td>
                        </tr>
                        <tr>
                            <td><code>ingestion/lambda_function.py</code></td>
                            <td>Remove <code>_validate_token()</code> - API Gateway handles this</td>
                        </tr>
                        <tr>
                            <td><code>config_inter_cloud.json</code></td>
                            <td>Replace <code>token</code> with <code>client_id</code>, <code>client_secret</code>,
                                <code>token_url</code>
                            </td>
                        </tr>
                        <tr>
                            <td><code>layer_2_compute.py</code></td>
                            <td>Deploy API Gateway and configure authorizer</td>
                        </tr>
                        <tr>
                            <td>All <code>*-writer</code> Lambdas</td>
                            <td>Same pattern - remove token validation, rely on API Gateway</td>
                        </tr>
                    </tbody>
                </table>

                <div class="callout tip mt-4">
                    <strong><i class="fa-solid fa-lightbulb me-2"></i>Recommendation</strong>
                    <p class="mb-0">Start with AWS API Gateway HTTP API type for the L1→L2 connection as a pilot.
                        It's the simplest to implement and provides immediate security benefits. Once validated,
                        extend to other cross-cloud connections.</p>
                </div>
            </div>

        </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="js/docs-nav.js" defer></script>
</body>

</html>