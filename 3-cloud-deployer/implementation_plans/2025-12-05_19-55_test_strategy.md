# Implementation Plan: Test Strategy for Cloud Deployer

**Date:** 2025-12-05
**Task:** Establish a testing framework and implement unit/integration tests, focusing on AWS.

## Goal
Ensure code reliability by implementing a testing suite. Given the current project state, **Integration Tests will focus exclusively on AWS**, while the structure will allow for future Azure and Google Cloud expansion.

## Analysis
-   **Current Scope:** Only AWS deployment logic is implemented in `src/aws/`.
-   **Future Scope:** Azure and GCP will be added later.
-   **Testing Approach:**
    -   **Unit Tests:** Generic utilities and configuration (`src/globals.py`, `src/util.py`).
    -   **Integration Tests (AWS):** Mocked interactions using `moto`.
    -   **Integration Tests (Azure/GCP):** *Out of scope* (will be empty directories or placeholders).

## Proposed Changes

### 1. Directory Structure
We will adopt a provider-centric structure for integration tests:
```
tests/
├── __init__.py
├── conftest.py              # Shared fixtures (mock config, env vars)
├── unit/
│   ├── __init__.py
│   ├── test_globals.py
│   └── test_util.py
├── integration/
│   ├── __init__.py
│   ├── aws/                 # <--- PRIMARY FOCUS
│   │   ├── __init__.py
│   │   ├── conftest.py      # AWS-specific fixtures (moto clients)
│   │   └── test_core_deployer_aws.py
│   ├── azure/               # Placeholder for future
│   │   └── __init__.py
│   └── google/              # Placeholder for future
│   │   └── __init__.py
└── api/
    ├── __init__.py
    └── test_rest_api.py
```

### 2. Dependencies
Install:
-   `pytest`
-   `moto[server]` (specifically `iam`, `lambda`, `iot`, `dynamodb`, `s3`, `events`, `sts`)
-   `httpx` (for FastAPI TestClient)
-   `boto3` (already present, but needed for tests)

### 3. Implementation Steps

#### Step 1: Framework Configuration
-   **`tests/conftest.py`**: Setup environment variables to prevent accidental cloud calls (e.g., `AWS_ACCESS_KEY_ID=testing`).
-   **`tests/integration/aws/conftest.py`**: Define `moto` fixtures for each service. This ensures isolation ensuring one test doesn't affect another.

#### Step 2: Unit Tests (Generic)
-   **`test_globals.py`**: Verify config loading handles missing files gracefully or defaults correctly.

#### Step 3: AWS Integration Tests (Mocked)
-   **`test_core_deployer_aws.py`**:
    -   **L1 (Dispatcher):** Verify IAM role, Lambda, and IoT rule creation.
    -   **L2 (Persister):** Verify Persister Lambda and Event Checker.
    -   **L3 (Storage):** Verify DynamoDB table creation and S3 Buckets (Hot/Cold/Archive).
    -   **L4/L5:** Verify TwinMaker and Grafana workspace creation (if supported by moto, otherwise mock `boto3` client directly).
    -   *CRUD Verification:* Test `deploy` creates resources and `destroy` removes them.

#### Step 4: API Tests
-   **`test_rest_api.py`**: Verify that calling `POST /deploy?provider=aws` triggers the correct underlying deployer functions (using mocks).

## Verification Plan
-   Execute `pytest tests/` in the Docker container.
-   Verify that all AWS tests pass.
-   Verify that Azure/Google requests raise `NotImplementedError` (if tested via API/CLI paths).
